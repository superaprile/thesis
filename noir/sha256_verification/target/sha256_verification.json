{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":10521738234818853453,"abi":{"parameters":[{"name":"a","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"b","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"c","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"d","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"5Z1bbttIEEX3ou98dD27K1sZDALnCQOGHcTOAIPAex85CRnbpCy7hJuwp3+CKOa5Kip12CWaor7t3n94+/XTm/PLj1fXu9d/fdtdXL07uzm/utw/+rbT7/90/fns8u7R9c3Zl5vd60qvdh8u3+9eU4nbV7uP5xcf9v9Ybl8tttTSpm2VhOaNxW7/frUzZLgjwysyvCHDAxlOBZpO0HSGpgs0HaopQT0lqKgENZWgqhLUVYa6ylBXGeoqQ11lqKsMdZWhrjLUVYa6ylBXBeqqQF0VqKsCdVWgrgrUVYG6KlBXBeqqQF1VqKsKdVWhrirUVYW6qlBXFeqqQl1VqKsKddWgrhrUVYO6alBXDeqqQV01qKsGddWgrhrUVYe66lBXHeqqQ111qKuOPQcMddWhrjrUVYe6Wk91lYOndNG4n77cmPfP/3NjJufHpdB2SuHtlCLbKeXE44tx6M9tTWSRbtB0h6ZXaHqDpgcyvRVoOkHTGZou0HSoqw3qaoO62qCuNqirDepqQF0NqKsBdTWgrgbU1YC6GlBXA+pqQF0NqKtUCjaesPGMjRdsvGLjDRvv2PiKjW/YeKy1hLWWsNYS1lrCWktYawlrLWGtJay1hLWWsNYy1lrGWstYaxlrLWOtZay1jLWWsdYy1lrGWitYawVrrWCtFay1grVWsNYK1lrBWitYa0+9JsusxhTvxR/Hn3pR1rF4wsYzNl6w8YqNN2y8Y+MrNr5h47HWGtZaw1prWGsNa61hrTWstYa11rDWGtZaw1rrWGsda61jrXWstY611rHWOtZax1rrWGsda23FWlux1lastRVrbcVaW7HWVqy1FWttxVpbsdY2rLUNa23DWtuw1jastQ1rbcNa27DWNqy1DWttYK0NrLWBtTaw1gbW2sBaG1hrA2ttYK0NqLVcCjaesPGMjT/RWmctP7d1KbyIV2y8YeMdG1+x8Q0bH9D4U6+NOhZP2HjGxmOtJay1hLX21Guj3Gj6jJSbxCK+YuMbNj6g8adeG3UsnrDxjI0XbLxi4w0bj7WWsdYy1lrGWitYawVrrWCtFay1grVWsNYK1lrBWitYawVrrWKtVay1irVWsdYq1lrFWqtYaxVrrWKtVay1hrXWsNYa1lrDWmtYaw1rrWGtNay1hrXWsNY61lrHWutYax1rrWOtday1jrXWsdY61lrHWlux1lastadeG+WtzqdJoyxv2i3YeMXGn2ptkM3xavfjlxs30Sm4iR/bWKfft7WHm34v2/ssu/ZZduuz7Oiy7FOvaftTZVOfZXOfZUufZWufZfe5SrY+V8nW5yrZ+lwlW5+rZPS5Skafq2T0uUpGn6vkqdfo/qmy+1wlo89VMvpcJaPPVTK6XCWldLlKSulylZTS5SoppctVUkqXq6SULldJKV2uklJ+7yrJPJddZVFL21AtsZ1aqGyoFtpQLbyhWmRDteiGarEN1eIbqmVDx136rcdddZ9qsYe/b11uvD9BMSXv3z3/2ph9ZWP79ZVTViLub/x9L2OEveQyxF7SEHvJQ+ylDLGXOsRe2hB76UPsZR1iL4eYfXiI2UeGmH1kiNlHhph9ZIjZ5+SPnvaxl0PMPjLE7CNDzD4yxOwjQ8w+OsTso0PMPjrE7KNDzD4nf4C/j70cYvbRIWYfHWL20SFmHx1i9rEhZh8bYvaxIWYfG2L2Ofk2KH3s5RCzjw0x+9gQs48NMfvYELOPDzH7+BCzjw8x+/gQs8/JN5PqYy+HmH18iNnHh5h9fIjZx4eYfeoQs08dYvapQ8w+9f8/++wfvP1yfnFx/unNxdW7s5vzq8vrO7Tc/bF+1p2K2/wK+OOvjlo/h/00s35G+AhDCYYTjCQYTTCWYDzB1AST6ANL9IEn+sATfeCJPvBEH3iiDzzRB57oA0/0gSf6YH22IarTwY4o2iNmfVI4wlCC4QQjCUaPMUyPP+a3fttEYq4zY49vf7p+Fz2yMjMmC0YTjCUYfzkTB5iYGS+PX+v1O5uQU8zM4nlo/U4XTz8Rrd9nYh/fZsiWz6QZyDKQZ6B6ANJfEC+gloEiAa1/tP4YRBmIM5BkIE00LFkG8gxUM1DLQBlzuWQgykCcgSQDZTqCMx3BmY7gTEdwpiP4xR2xf0B3mx44+pmWack1Zb19+H7vwNHvGNQyUCSg9aPfMYgy0Prbe7bpQFa5PvPodwzSBHTgc6tSpzm0SrPndWDVMt1Pviotnmn9c03MPg0G+7/GApIMpBmoJV6IA1fYP/1CHLhg/QhEGYgzkGQgzUCWgTwD1QyU6XLNdIRlOsIyHWGZjrBMR9iLO2L/gH8sOOtrx5MnGA+tHUegSEAH1o4jEGUgzkDrbRs0Qfu/yvPGuBouM1TjeWPcMUgykGYgy0CegWoGahkoEtD6p8NbmTuiFV50xPqHrfdQmSF5cIJqebJc2aYVV/nezZfWz6w/PUatTw9/rhzZVjm6rXJsW+X4tsqp2yqnbauc2FQ5WrZVzraOynpAdJt//VqsPm+ubsXbDC3faWkkICsZiDKQJl4IO/Dq1XvPpAvIM1DNQC0DHfh/ajNEpTyGvGQgykCcgSQDaQayDOSJhvWagTLmesbcmjG3ZsytnIEkA2kGsgyU6Yia6Yia6Yia6YiW6YiW6YgD30T29BvoA98DFjyffA3xBeQZqGagloEiAR349qUjEGUgzkCSgTQDZToiMh0RmY6ITEdEoiO4vLgjbveP/jn7cn729uLD3SV0dz/8evluuqJu//Dm388/frLf+D8=","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"35":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n","path":"std/hash/sha256.nr"},"70":{"source":"\nfn main(a: u8, b: u8, c: u8, d: u8) -> pub [u8; 32] {\n\n    let hash = std::hash::sha256_var([a, b, c, d], 4);\n    hash\n}\n\n","path":"/home/superaprile/workspace/thesis/noir/sha256_verification/src/main.nr"}},"names":["main"],"brillig_names":["build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","directive_integer_quotient","directive_invert"]}